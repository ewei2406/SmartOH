\documentclass{article}\usepackage{lipsum}\begin{document}\section{DFS - Depth-First Search}DFS is an algorithm for traversing or searching tree or graph data structures. It starts at the root node and explores as far as possible along each branch before backtracking.\section{Properties of DFS}The time and space analysis of DFS differ according to its application area.\begin{itemize}\item In theoretical computer science, DFS is typically used to traverse an entire graph and takes time O(|V| + |E|), where |V| is the number of vertices and |E| is the number of edges.\item For applications in specific domains, such as searching for solutions in artificial intelligence or web-crawling, DFS is often applied to a limited depth due to resource limitations. The time complexity remains linear, but the space complexity is proportional to the depth limit, making it smaller than breadth-first search.\end{itemize}\section{Example of Depth-First Search}In the example of a depth-first search on the given graph, starting at node A, the nodes are visited in the following order: A, B, D, F, E, C, G.\section{Output of Depth-First Search}The result of a depth-first search can be described in terms of a spanning tree of the visited vertices. The edges of the original graph can be categorized into forward edges, back edges, and cross edges based on this spanning tree.\section{Vertex Orderings in DFS}Depth-first search can also be used to linearly order the vertices of a graph or tree. There are four possible ways to do this: preordering, postordering, reverse preordering, and reverse postordering.\section{Pseudocode for Recursive DFS}Here is a recursive implementation of DFS:\texttt{procedure DFS(G, v) is\\hspace*{1em}label v as discovered\\hspace*{1em}for all directed edges from v to w that are in G.adjacentEdges(v) do\\hspace*{2em}if vertex w is not labeled as discovered then recursively call DFS(G, w)}\section{Pseudocode for Iterative DFS}Here is a non-recursive implementation of DFS:\texttt{procedure DFS\_iterative(G, v) is\\hspace*{1em}let S be a stack\\hspace*{1em}S.push(v)\\hspace*{1em}while S is not empty do\\hspace*{2em}v = S.pop()\\hspace*{2em}if v is not labeled as discovered then label v as discovered\\hspace*{2em}for all edges from v to w in G.adjacentEdges(v) do\\hspace*{3em}S.push(w)}}